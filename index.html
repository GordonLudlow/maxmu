<!DOCTYPE html>
<!--
 MaxMu: Given a set of points (in lat,lng), find the largest area triangle.  From the set of points within that triangle (including 2 of the three outer triangle vertices), find the second largest triangle.  Repeat until there are no points within the innermost triangle.
 In the degenerate case, this will yield a standard layered field, but in the typical case the spine will be non-continuous.  Build the field inside out, creating the triangle first and then linking to the third portal of the inner triangle.
-->
<html>
<head>
<title>Max Mu</title>
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
<style type="text/css">
html { height: 100%; }
body { height: 100%; margin: 0; padding: 0; }
.container {display: flex; height: 100%; flex-direction: column;}
/* TODO use a smaller font for high res small screen devices to make the selection list easier to click
Media queries have "in" for inches, but it's a lie because it really means 96 pixels and smart phones are much higher dpi than that.
So I think it'll take a block of media queries for all the diffent dpi possibilities.
I mean, it'd be neat if you could easily say, "use a bigger font if the screen is less than 8 inches."  But css predates iPhones and Androids, so there you go.
#playbox {font-size: 2em;}
*/
#map_canvas {width:100%; height:50%; min-height: 200px;}
#border {width: 100%; height: 1%; min-height: 5px; background-color: #0078B5; cursor: ns-resize;}
#results {width:100%; height:49%; overflow:auto; min-height: 100px;}
#prompt {text-align: center;}
ul.no_bullet {list-style-type: none; padding: 0; margin: 0; }
li.checked {background: url('./images/checked.png') no-repeat left top; padding-left: 36px; padding-top: 4px; line-height: 1.5em; height:auto}
li.unchecked {background: url('./images/unchecked.png') no-repeat left top; padding-left: 36px; padding-top: 4px; line-height: 1.5em; height:auto}
</style>

<script type="text/javascript">

// https://github.com/indy256/convexhull-js/blob/master/convexhull.js
(function () {
 'use strict';
 
 function convexHull(points) {
 points.sort(function (a, b) {
             return a.x != b.x ? a.x - b.x : a.y - b.y;
             });
 
 var n = points.length;
 var hull = [];
 
 for (var i = 0; i < 2 * n; i++) {
 var j = i < n ? i : 2 * n - 1 - i;
 while (hull.length >= 2 && removeMiddle(hull[hull.length - 2], hull[hull.length - 1], points[j]))
 hull.pop();
 hull.push(points[j]);
 }
 
 hull.pop();
 return hull;
 }
 
 function removeMiddle(a, b, c) {
 var cross = (a.x - b.x) * (c.y - b.y) - (a.y - b.y) * (c.x - b.x);
 var dot = (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y);
 return cross < 0 || cross == 0 && dot <= 0;
 }
 
 // export as AMD module / Node module / browser or worker variable
 if (typeof define === 'function' && define.amd) define(function () { return convexHull; });
 else if (typeof module !== 'undefined') module.exports = convexHull;
 else if (typeof self !== 'undefined') self.convexHull = convexHull;
 else window.convexHull = convexHull;
 })();

// https://github.com/mattdesl/point-in-triangle (modified for data format)
function pointInTriangle(point, triangle) {
    //compute vectors & dot products
    var cx = point.x, cy = point.y,
        t0 = triangle[0], t1 = triangle[1], t2 = triangle[2],
        v0x = t2.x-t0.x, v0y = t2.y-t0.y,
        v1x = t1.x-t0.x, v1y = t1.y-t0.y,
        v2x = cx-t0.x, v2y = cy-t0.y,
        dot00 = v0x*v0x + v0y*v0y,
        dot01 = v0x*v1x + v0y*v1y,
        dot02 = v0x*v2x + v0y*v2y,
        dot11 = v1x*v1x + v1y*v1y,
        dot12 = v1x*v2x + v1y*v2y

    // Compute barycentric coordinates
    var b = (dot00 * dot11 - dot01 * dot01),
        inv = b === 0 ? 0 : (1 / b),
        u = (dot11*dot02 - dot01*dot12) * inv,
        v = (dot00*dot12 - dot01*dot02) * inv
    return u>=0 && v>=0 && (u+v < 1)
}

function GetURLParameter(sParam)
{
    let sPageURL = window.location.search.substring(1);
    let sURLVariables = sPageURL.split('&');
    for (let i = 0; i < sURLVariables.length; i++)
    {
        let sParameterName = sURLVariables[i].split('=');
        if (sParameterName[0] == sParam)
        {
            return sParameterName[1];
        }
    }
}

function PlsArgToArray(plsArg) {
    if (plsArg.includes("_")) {
        return plsArg.split("_").map(function(e) {
            return e.split(",").map(Number);
        });
    }
    return plsArg.split(",").map(Number);
}

var triangleCount = 0;
var maxLayers = 9999;
var maxKeys = 9999;
var maxKeysPerPortal = 9999;
var continuousSpine = false;
var keysRequired = {};

const ignoredPortal = './images/enl_reso_01.png';
const unusedPortal = './images/neutral.png';

function ResetFieldState() {
    triangleCount = 0;
    keysRequired = {};
    selectingPortals = false;
    selectedPortals = [];

    // Remove dom elements that were dynamically added
    $("#keys_required").empty();
    $("#links").empty();
    $("#prompt").html("");
    
    // Turn all the portals back to green (= not needed) and unhide hidden portals
    for (marker in markers) {
        if (markers[marker].getIcon().url == './images/hum_reso_08.png') {
            markers[marker].setIcon({url: unusedPortal, scaledSize: new google.maps.Size(20, 20), anchor: new google.maps.Point(10,10)});
        }
        else {
            markers[marker].setMap(map);
        }
    }
    
    // Remove all per-field map elements
    for (element in fieldSpecificMapElements) {
        fieldSpecificMapElements[element].setMap(null);
    }
    
    // Remove field related text content
    $("#layer_count").html("");
    $("#keys_heading").html("");
    $("#links_heading").html("");
    $("#outer_triangle").html("");
    $("#share").html("");
}

function IncrementKeyCount(portal, count) {
    // We're using this portal for the field, change its icon
    markers[portal.guid].setIcon({url: './images/hum_reso_08.png', scaledSize: new google.maps.Size(20, 20), anchor: new google.maps.Point(10,10)});
    if (keysRequired.hasOwnProperty(portal.guid)) {
        keysRequired[portal.guid].count += count;
    }
    else {
        keysRequired[portal.guid] = {guid: portal.guid, count: count, title: portal.title, lat: portal.lat, lng: portal.lng};
    }
}

function FormatTriangle(p0,p1,p2) {
    return "pls="
              + p0.lat + "," + p0.lng + "," + p1.lat + "," + p1.lng
        + "_" + p0.lat + "," + p0.lng + "," + p2.lat + "," + p2.lng
        + "_" + p1.lat + "," + p1.lng + "," + p2.lat + "," + p2.lng;
}

function FormatTriangleAndBackLink(p0,p1,p2,bl) {
    return "pls="
              + p0.lat + "," + p0.lng + "," + p1.lat + "," + p1.lng
        + "_" + p0.lat + "," + p0.lng + "," + p2.lat + "," + p2.lng
        + "_" + p1.lat + "," + p1.lng + "," + p2.lat + "," + p2.lng
        + "_" + p0.lat + "," + p0.lng + "," + bl.lat + "," + bl.lng;
}

function FormatPortal(p) {
    return `pll=${p.lat},${p.lng}`;
}

function FieldGuid(triangle) {
    let guids = [triangle[0].guid, triangle[1].guid, triangle[2].guid];
    guids.sort();
    return guids[0] + "___" + guids[1] + "___" + guids[2];
}

function ExtendedFieldGuid(triangle) {
    let guid = FieldGuid(triangle);
    if (maxLayers < 9999) {
        guid += "__L" + maxLayers;
    }
    if (maxKeys < 9999) {
        guid += "__K" + maxKeys;
    }
    if (maxKeysPerPortal < 9999) {
        guid += "__P" + maxKeysPerPortal;
    }
    if (continuousSpine) {
        guid += "__C";
    }

    return guid;
}

function ParseExtendedFieldGuid(guid) {
    // At the end of the guid, any user entered overrides will be encoded as:
    // __L<maxLayers>
    // __K<maxKeys>
    // __P<maxKeysPerPortal>
    // __C for continuous spine

    let portalGuids = guid.split(/___/g);
    let overrides = portalGuids[2].split(/__/g);
    portalGuids[2] = overrides[0];
    
    for (let override = 1; override < overrides.length; override++) {
        switch (overrides[override][0]) {
            case "L":
                maxLayers = parseInt(overrides[override].slice(1), 10);
                break;
            case "K":
                maxKeys = parseInt(overrides[override].slice(1), 10);
                break;
            case "P":
                maxKeysPerPortal = parseInt(overrides[override].slice(1), 10);
                break;
            case "C":
                continuousSpine = true;
                break;
        }
    }

    let triangle = [];
    for (let i in portalGuids) {
        triangle[i] = allPortals.find(p => p.guid == portalGuids[i]);
    }
    
    return triangle;
}

function FieldTitle(triangle) {
    return triangle[0].title + "->" + triangle[1].title + "-> "+ triangle[2].title;
    return title;
}

function SelectFieldInDropDown(triangle) {
    let fieldGuid = FieldGuid(triangle);

    let exists = false;
    $('#playbox option').each(function(){
        if (this.value == fieldGuid) {
            exists = true;
            return false;
        }
    });
    if (!exists) {
        // Add it
        let fieldTitle = FieldTitle(triangle);
        $('#playbox').append($('<option>', {
            value: fieldGuid,
            text : fieldTitle
        }));
                  
        let objectStore = fieldDB.transaction(['fields'],'readwrite').objectStore('fields');
        objectStore.add({"guid": fieldGuid, "title": fieldTitle, "triangle": triangle});
    }
    $("#playbox").val(fieldGuid); // Select it
}

function FindLargestInnerTriangle(triangle, portal, stealth) {
    if (verbose) {
        console.log("FindLargestInnerTriangle");
        console.log(triangle);
        console.log(portal.length + " portals");
        console.log(stealth? "stealth mode" : "updating map and DOM");
    }

    // Cull points not strictly in the triangle
    let i = portal.length;
    while (i--) {
        if (portal[i].guid == triangle[0].guid
        || portal[i].guid == triangle[1].guid
        || portal[i].guid == triangle[2].guid
        || !pointInTriangle(portal[i], triangle)) {
            portal.splice(i,1);
        }
        else if (portal[i].guid == triangle[0].guid) {
            console.log("guids are equal.  what's up?");
            debugger;
        }
    }
    
    let mkpp = 0;
    for (let key in keysRequired) {
        if (keysRequired[key].count > mkpp)
            mkpp = keysRequired[key].count;
    }

    if (!portal.length || triangleCount == maxLayers || (triangleCount+1)*3 > maxKeys || (mkpp >= maxKeysPerPortal)) {
        // We're at the end which is really the beginning.
        // The throws don't matter on this inner triangle.  One portal needs no keys, one needs a key and the third needs 2 keys.
        // So pick the one with the most keys already required to thow from so we don't increase it's count any more.
        // NOTE: We need to preserve the order of the vertices of the triangle so as not to break the first back link.  So we sort a copy.
        let copy = triangle.slice();
        if (!continuousSpine) {
            copy.sort((a,b) => {
                let aCount = 0;
                let bCount = 0;
                if (keysRequired.hasOwnProperty(a.guid)) {
                    aCount = keysRequired[a.guid].count
                }
                if (keysRequired.hasOwnProperty(b.guid)) {
                    bCount = keysRequired[b.guid].count
                }
                return bCount - aCount;
            });
        }
        IncrementKeyCount(copy[0], 0);
        IncrementKeyCount(copy[1], 1);
        IncrementKeyCount(copy[2], 2);
        
        if (!stealth) {
            let compositeGuid = copy[0].guid + "_" + copy[1].guid + "_" + copy[2].guid;
            $("#links").append("<li class=\"unchecked\" id=\""
                + compositeGuid
                + "\">"
                + "Link <a href=\"https://intel.ingress.com/intel?"
                + FormatTriangle(copy[0], copy[1], copy[2])
                + "&" + FormatPortal(copy[0]) + "\" target=\"_blank\">"
                + `${copy[0].title}</a>`
                + " to <br /> <a href=\"https://intel.ingress.com/intel?"
                + FormatTriangle(copy[0], copy[1], copy[2])
                + "&" + FormatPortal(copy[1]) + "\" target=\"_blank\">"
                + `${copy[1].title}</a>`
                + " and <br /> <a href=\"https://intel.ingress.com/intel?"
                + FormatTriangle(copy[0], copy[1], copy[2])
                + "&" + FormatPortal(copy[2]) + "\" target=\"_blank\">"
                + `${copy[2].title}</a>`
                + "</li>");
            $("#"+compositeGuid).data("checked", false);
        
            compositeGuid = copy[1].guid + "_" + copy[2].guid;
            $("#links").append("<li class=\"unchecked\" id=\""
                + compositeGuid
                + "\">"
                + "Link <a href=\"https://intel.ingress.com/intel?"
                + FormatTriangle(copy[0], copy[1], copy[2])
                + "&" + FormatPortal(copy[1]) + "\" target=\"_blank\">"
                + `${copy[1].title}</a>`
                + " to <br /> <a href=\"https://intel.ingress.com/intel?"
                + FormatTriangle(copy[0], copy[1], copy[2])
                + "&" + FormatPortal(copy[2]) + "\" target=\"_blank\">"
                + `${copy[2].title}</a>`
                + "</li>");
        }
        
        let a = copy[0];
        let b = copy[1];
        let c = copy[2];
        let innermostArea = Math.abs(
              (a.x * (b.y-c.y))
            + (b.x * (c.y-a.y))
            + (c.x * (a.y-b.y))
        );
        if (verbose) {
            console.log("Innermost triangle area " + innermostArea);
            console.log(triangle);
            console.log(copy);
        }
        return innermostArea;
    }
    
    triangleCount++;
    
    let maxArea = 0;
    let innerTriangle = [];
    let previousPoint = {};

    let b,c;
    if (continuousSpine) {
        let tempTri = JSON.parse(JSON.stringify(triangle));
        previousPoint = tempTri[0];

        b = tempTri[1];
        c = tempTri[2];
    }

    for (let i=0; i<portal.length; i++) {
        let a = portal[i];
        if (continuousSpine) {
            let area = Math.abs(
                (a.x * (b.y-c.y))
                + (b.x * (c.y-a.y))
                + (c.x * (a.y-b.y))
            );
            if (area > maxArea) {
                maxArea = area;
                innerTriangle = [a, b, c];
            }
        }
        else {
            for (let exclude=0; exclude<3; exclude++) {
                let tempTri = JSON.parse(JSON.stringify(triangle));
                let excluded = JSON.parse(JSON.stringify(tempTri[exclude]));
                tempTri.splice(exclude,1);
            
                b = tempTri[0];
                c = tempTri[1];

                let area = Math.abs(
                    (a.x * (b.y-c.y))
                    + (b.x * (c.y-a.y))
                    + (c.x * (a.y-b.y))
                );
                if (area > maxArea) {
                    maxArea = area;
                    innerTriangle = [a, b, c];
                    previousPoint = excluded;
                }
            }
        }
    }
    
    if (verbose) {
        console.log("Next point");
        console.log(innerTriangle[0]);
    }
    
    if (!stealth) {
        // Draw the inner triangle
        let polygon = new google.maps.Polygon({
            paths: innerTriangle,
            strokeColor: '#0000FF',
            strokeOpacity: 1,
            strokeWeight: 2,
            fillColor: '#0000FF',
            fillOpacity: 0.05,
            map: map
        });
        fieldSpecificMapElements.push(polygon);
    
        // Draw the spine segment
        polyLine = new google.maps.Polyline({
                    path: [new google.maps.LatLng(innerTriangle[0]),
                        new google.maps.LatLng(previousPoint)],
                        strokeColor: '#FF0000',//lineColors[to],
                        strokeOpacity: 1.0,
                        strokeWeight: 2,
                        map: map
        });
        fieldSpecificMapElements.push(polyLine);
    }
    
    IncrementKeyCount(previousPoint, 0);
    IncrementKeyCount(innerTriangle[0], 1);
    IncrementKeyCount(innerTriangle[1], 1);
    IncrementKeyCount(innerTriangle[2], 1);
    
    let innerArea = FindLargestInnerTriangle(innerTriangle, portal, stealth);

    if (!stealth) {
        let compositeGuid = previousPoint.guid + "_" + innerTriangle[1].guid + "_" + innerTriangle[2].guid + "_" + innerTriangle[0].guid;
        let urlPrefix = "<a href=\"https://intel.ingress.com/intel?" + FormatTriangleAndBackLink(previousPoint, innerTriangle[1], innerTriangle[2], innerTriangle[0]);
        $("#links").append("<li class=\"unchecked\" id=\""
            + compositeGuid
            + "\">"
            + "Link "                + urlPrefix + "&" + FormatPortal(previousPoint)    + "\" target=\"_blank\">" + `${previousPoint.title}</a>`
            + " to <br /> "          + urlPrefix + "&" + FormatPortal(innerTriangle[1]) + "\" target=\"_blank\">" + `${innerTriangle[1].title}</a>`
            + " and <br /> "         + urlPrefix + "&" + FormatPortal(innerTriangle[2]) + "\" target=\"_blank\">" + `${innerTriangle[2].title}</a>`
            + " and then to <br /> " + urlPrefix + "&" + FormatPortal(innerTriangle[0]) + "\" target=\"_blank\">" + `${innerTriangle[0].title}</a>`
            + "</li>");
        $("#"+compositeGuid).data("checked", false);
    }
    
    return maxArea + innerArea;
}

function FindIndex(portal, latlng) {
    for (let i=0; i<portal.length; i++) {
        if (portal[i].lat == latlng[0] && portal[i].lng == latlng[1]) {
            return i;
        }
    }
    console.log(`Error: Specified portal not found.  latlng = ${latlng[0]}, ${latlng[1]}`);
    $("#results").append(`<p><font color="red">ERROR</font>&nbsp;<a href="https://intel.ingress.com/intel?pll=${latlng[0]},${latlng[1]}" target="_blank">Unknown portal</a></p>`);

}

function SanitizeGuid(guid) {
    // Convert the guid into a string that can be used as an ID for a DOM element
    const reservedCharacters = "!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~";
    let sanitized = "";
    if (guid[0] >= '0' && guid[0] <= '9') {
        sanitized = "g";
    }
    for (let i=0; i<guid.length; i++) {
        if (reservedCharacters.includes(guid[i])) {
            sanitized += "_";
        }
        else {
            sanitized += guid[i];
        }
    }
    return sanitized;
}

function CapLayerCount() {
    maxLayers = parseInt($('#triangleCap').val(), 10);
    ResetFieldState();
    BuildField(allPortals.slice(), $("#results").data("triangle"));
}

function UncapLayerCount() {
    maxLayers = 9999;
    ResetFieldState();
    BuildField(allPortals.slice(), $("#results").data("triangle"));
}

function CapKeyCount() {
    maxKeys = parseInt($('#keyCap').val(), 10);
    ResetFieldState();
    BuildField(allPortals.slice(), $("#results").data("triangle"));
}

function UncapKeyCount() {
    maxKeys = 9999;
    ResetFieldState();
    BuildField(allPortals.slice(), $("#results").data("triangle"));
}

function CapKppCount() {
    maxKeysPerPortal = parseInt($('#kppCap').val(), 10);
    ResetFieldState();
    BuildField(allPortals.slice(), $("#results").data("triangle"));
}

function UncapKppCount() {
    maxKeysPerPortal = 9999;
    ResetFieldState();
    BuildField(allPortals.slice(), $("#results").data("triangle"));
}

function AllowDiscontinuousSpine() {
    continuousSpine = false;
    ResetFieldState();
    BuildField(allPortals.slice(), $("#results").data("triangle"));
}

function RequireContinuousSpine() {
    continuousSpine = true;
    ResetFieldState();
    BuildField(allPortals.slice(), $("#results").data("triangle"));
}

function ReasonableCap(count) {
    let reasonableCap = 5;
    if (count > 100)
        reasonableCap = 100;
    else if (count > 50)
        reasonableCap = 50;
    else if (count > 10)
        reasonableCap = count - (count % 10);
    return reasonableCap;
}
var map;
var mapInitialized = false;
var fieldSpecificMapElements = [];

var fieldDB = false; // IndexedDB database of field parameters
var checkboxDB = false; // IndexedDB database of which checkboxes are checked for a field
// One table in the each DB.
// fields: guid => guid, title, triangle
// checkboxes: guid => guid, checked

var markers = {};

var selectingPortals = false;
var selectedPortals = [];

function BuildField(portal, triangle) {
    // TODO: Move all the math to a web worker (or maybe not.  It's really fast).  Also, move the javascript and css out of index.html.

    if (verbose) {
        console.log("Build Field.  " + portal.length + " portals.");
        console.log(triangle);
    }

    triangleCount = 1;
    
    // Recursively find all the triangles
    if (continuousSpine) {
        // Triangle should be [spine, anchor, anchor] (that's what FindLargestInnerTriangle assumes)
        let option = [];
        option.push(triangle);
        option.push([triangle[1], triangle[0], triangle[2]]);
        option.push([triangle[2], triangle[0], triangle[1]]);
    
        if (verbose) { console.log("trial0"); console.log(option[0]); }
        let bestSpine = 0;
        let bestArea = FindLargestInnerTriangle(option[0], portal.slice(), true);
        if (verbose) {
            console.log(option[0]);
            console.log(" area0 " + bestArea);
        }
        ResetFieldState();
        triangleCount = 1;
        
        if (verbose) { console.log("trial1"); console.log(option[1]); }
        let area = FindLargestInnerTriangle(option[1], portal.slice(), true);
        if (verbose) {
            console.log(option[1]);
            console.log(" area1 " + area);
        }
        if (area > bestArea) {
            console.log("new best");
            bestArea = area;
            bestSpine = 1;
        }
        ResetFieldState();
        triangleCount = 1;

        if (verbose) { console.log("trial2"); console.log(option[1]); }
        area = FindLargestInnerTriangle(option[2], portal.slice(), true);
        if (verbose) {
            console.log(option[2]);
            console.log(" area2 " + area);
        }
        if (area > bestArea) {
            console.log("new best");
            bestArea = area;
            bestSpine = 2;
        }

        if (verbose) {
            console.log(option[bestSpine]);
        }
        
        ResetFieldState();
        triangleCount = 1;
        FindLargestInnerTriangle(option[bestSpine], portal, false);

        console.log("Continuous spine area " + bestArea);
    }
    else {
        let bestArea = FindLargestInnerTriangle(triangle, portal, false);
        console.log("Discontinuous spine area " + bestArea);
    }

    // Draw the triangle
    let polygon = new google.maps.Polygon({
        paths: triangle,
        strokeColor: '#0000FF',
        strokeOpacity: 1,
        strokeWeight: 2,
        fillColor: '#0000FF',
        fillOpacity: 0.1,
        map: map
    });
    fieldSpecificMapElements.push(polygon);
    
    $("#results").data("triangle", triangle);
    $("#links_heading").html("Links:");
    
    let layerCountHtml = triangleCount + " layers"
        + " ( <input type=\"number\" id=\"triangleCap\" name=\"triangleCap\"";
    if (maxLayers == 9999) {
        layerCountHtml += " value = \"7\"";
    }
    else {
        layerCountHtml += " value = \"" + triangleCount + "\"";
    }
    layerCountHtml += " min=\"1\" max=\"999\">"
        + " <button onclick='CapLayerCount();'>cap</button> ";
    if (maxLayers < 9999) {
        layerCountHtml += " <button onclick='UncapLayerCount();'>uncap</button>";
    }
    layerCountHtml += " )";
    if (continuousSpine) {
        layerCountHtml += " with a continuous spine (<button onclick='AllowDiscontinuousSpine();'>allow discontinuous</button>)";
    }
    else {
        layerCountHtml += " with a discontinuous spine (<button onclick='RequireContinuousSpine();'>require continuous</button>)";
    }
    $("#layer_count").html(layerCountHtml);
            
    let sortedKeys = [];
    for (let key in keysRequired) {
        if (keysRequired.hasOwnProperty(key)) {
            sortedKeys.push(keysRequired[key]);
        }
    }
    sortedKeys.sort((a, b) => b.count - a.count);
    let first=true;
    for (let key in sortedKeys) {
        let liHtml = ("    " + sortedKeys[key].count).slice(-4)
            + " <a href="
            + `"https://intel.ingress.com/intel?pll=${sortedKeys[key].lat},${sortedKeys[key].lng}" target="_blank">`
            + `${sortedKeys[key].title}</a>`;
        if (first) {
            first = false;
            let capHtml = "";
            if (sortedKeys[key].count > 5) {
                capHtml = " <input type=\"number\" id=\"kppCap\" name=\"kppCap\""
                        + " value = \"";
                if (maxKeysPerPortal < 9999) {
                    capHtml += maxKeysPerPortal;
                }
                else {
                    capHtml += ReasonableCap(sortedKeys[key].count);
                }
                capHtml += "\""
                        + " min=\"1\" max=\"999\">"
                        + " <button onclick='CapKppCount();'>cap</button> ";
            }
            if (maxKeysPerPortal < 9999) {
                capHtml += " <button onclick='UncapKppCount();'>uncap</button> ";
            }
            if (capHtml.length) {
                liHtml += " (" + capHtml + ")";
            }
        }
        $("#keys_required").append("<li class=\"unchecked\" id=\""
            + sortedKeys[key].guid
            + "\">"
            + liHtml
            + "</li>");
        $("#"+sortedKeys[key].guid).data("checked", false);
    }
    let requiredKeyCount = function(items, prop){
        return items.reduce( function(a, b){
            return a + b[prop];
        }, 0)
    }(sortedKeys, "count");
    let requiredKeysHtml = requiredKeyCount + " keys required";
    let capHtml = "";
    if (requiredKeyCount > 10) {
        capHtml = " <input type=\"number\" id=\"keyCap\" name=\"keyCap\""
            + " value = \"";
        if (maxKeys < 9999) {
            capHtml += maxKeys;
        }
        else {
            capHtml += ReasonableCap(requiredKeyCount);
        }
        capHtml += "\""
            + " min=\"1\" max=\"999\">"
            + " <button onclick='CapKeyCount();'>cap</button> ";
    }
    if (maxKeys < 9999) {
        capHtml += " <button onclick='UncapKeyCount();'>uncap</button> ";
    }
    if (capHtml.length) {
        requiredKeysHtml += " (" + capHtml + ")";
    }
    $("#keys_heading").html(requiredKeysHtml);

    // Center the map
    let center = {};
    center.lat = (triangle[0].lat + triangle[1].lat + triangle[2].lat)/3;
    center.lng = (triangle[0].lng + triangle[1].lng + triangle[2].lng)/3;
    map.setCenter(new google.maps.LatLng(center));
    
    // Hide unused portals
    for (marker in markers) {
        if (markers[marker].getIcon().url != './images/hum_reso_08.png') {
            markers[marker].setMap(null);
        }
    }
    // The stock intel page errors out with more than a dozen triangles.  So let's just do the outermost
    $("#outer_triangle").attr('href',
        "https://intel.ingress.com/intel?ll="
        + center.lat
        + ","
        + center.lng
        + "&" + FormatTriangle(triangle[0], triangle[1], triangle[2])
    );
    $("#outer_triangle").html("Outer triangle");
    
    // Link for sharing the current field
    let shareHref = window.location.origin + window.location.pathname + "?";
    if (verbose)
        shareHref += "verbose=true&";
    shareHref += "guid=" + ExtendedFieldGuid(triangle);
    $("#share").attr('href', shareHref);
    $("#share").html("Share");

    // Open the IndexedDB containing which checkboxes should be checked
    let request = window.indexedDB.open("MaxMu" + ExtendedFieldGuid(triangle), 1);
    request.onerror = function(event) {
        console.error("openDb:", event.target.errorCode);
        checkboxDB = false;
    };
    request.onsuccess = function(event) {
        checkboxDB = event.target.result;
        let store = checkboxDB.transaction(['checkboxes'],'readonly').objectStore('checkboxes');
        store.getAll().onsuccess = function(e) {
            if (e.target.result) {
                let result = e.target.result;
                result.forEach(function(checkBoxRecord) {
                    // change the checkedness of the element using it's id/guid to look it up.
                    if (checkBoxRecord.checked) { // we default to unchecked, so only have to change it if it's checked
                        let checkBox = $("#"+checkBoxRecord.guid);
                        checkBox.data("checked", true);

                        checkBox.addClass("checked");
                        checkBox.removeClass("unchecked");
                    }
                });
            }
        };
    };
    request.onupgradeneeded = function(event) {
        checkboxDB = event.target.result;
        keyStore = checkboxDB.createObjectStore("checkboxes", { keyPath: "guid" });
    }

    // Check box toggling
    $("li").on("click", function(event) {
        if (event.target === event.currentTarget) { // only consume clicks on the bullet.  The content of the li is a link.
            $(this).toggleClass("unchecked");
            $(this).toggleClass("checked");
            if (checkboxDB) {
                let objectStore = checkboxDB.transaction(['checkboxes'],'readwrite').objectStore('checkboxes');
                let guid = $(this).attr('id');
                let checked = $(this).hasClass("checked");
                let req = objectStore.openCursor(guid);
                req.onsuccess = function(e) {
                    let cursor = e.target.result;
                    if (cursor) { // key already exists
                        const updateData = cursor.value;
                        updateData.checked = checked;
                        cursor.update(updateData);
                    } else { // key does not exist
                        objectStore.add({guid: guid, checked: checked});
                    }
                };
            }
            return false;
        }
        return true;
    });
}

var allPortals = []; // array of all known portals
var verbose;

function initializeMap()
{
    if (!mapInitialized)
    {
        // Default map options
        var mapOptions = { center: new google.maps.LatLng(47.488451,-122.169666),
                            zoom: 15,
                            mapTypeId: google.maps.MapTypeId.ROADMAP };
        
        map = new google.maps.Map(document.getElementById("map_canvas"), mapOptions);
        mapInitialized=true;
        
        verbose = GetURLParameter("verbose");

        // Load the portal coordinates
        // [{"title":"Title", "guid":"guid", "latlng":"lat,lng"},...]
        $.ajaxSetup({
            cache:false
        });
        let jsonFile = 'portals.json';
        // This is wrong.  The server should be configured to server up .json.gz instead of .json.
        //if (location.hostname != "localhost" && location.hostname != "127.0.0.1")
        //    jsonFile += '.gz';
        $.getJSON(jsonFile, function (data) {
            let ignore = data.ignore;
            for (let i=0; i<data.portals.length; i++) {
                let latlngArray = data.portals[i].latlng.split(',');
                let lat = parseFloat(latlngArray[0]);
                let lng = parseFloat(latlngArray[1]);
                let rawGuid = data.portals[i].guid;
                
                data.portals[i].lat = lat;
                data.portals[i].lng = lng;
                data.portals[i].x = lng; // convexHull function wants x,y
                data.portals[i].y = lat;
                data.portals[i].guid = SanitizeGuid(rawGuid);
                  
                if (ignore.some(e => e.guid === rawGuid)) {
                    console.log("Skipping " + data.portals[i].title);
                    let marker  = new google.maps.Marker({
                        position: new google.maps.LatLng(lat, lng),
                        map: map,
                        icon: {url: ignoredPortal, scaledSize: new google.maps.Size(20, 20), anchor: new google.maps.Point(10,10)},
                        title: data.portals[i].title + " " + data.portals[i].latlng
                    });
                    markers[data.portals[i].guid] = marker;
                    let infoWindow = new google.maps.InfoWindow({
                        content: data.portals[i].title + " " + data.portals[i].latlng
                    });
                    google.maps.event.addListener(marker, 'click', function () {
                        infoWindow.open(map, marker);
                    });
                    continue;
                }
                
                let name = data.portals[i].title + " " + data.portals[i].latlng;
                let guid = data.portals[i].guid;
                let marker = new google.maps.Marker({
                    position: new google.maps.LatLng(lat, lng),
                    map: map,
                    icon: {url: unusedPortal, scaledSize: new google.maps.Size(20, 20), anchor: new google.maps.Point(10,10)},
                    title: name
                });
                markers[guid] = marker;
                
                let div = document.createElement('div');
                div.innerHTML = name;
                jQuery.data(div, "portal", data.portals[i]);
                div.onclick = function(){
                    if (selectingPortals) {
                        let portal = jQuery.data(this, "portal");
                        let selectedIndex = selectedPortals.indexOf(portal);
                        if (selectedIndex > -1) {
                            // Unselect it
                            markers[portal.guid].setIcon({url: unusedPortal, scaledSize: new google.maps.Size(20, 20), anchor: new google.maps.Point(10,10)});
                            // Remove any yellow line we may have drawn
                            if (selectedPortals.length == 2) {
                                for (element in fieldSpecificMapElements) {
                                    fieldSpecificMapElements[element].setMap(null);
                                }
                            }
                            selectedPortals.splice(selectedIndex, 1);
                        }
                        else {
                            if (selectedPortals.length == 2) {
                                // This is the third point.  Exit selection mode and generate the field.
                                let triangle = [selectedPortals[0], selectedPortals[1], portal].slice();
                                selectedPortals = [];
                                selectingPortals = false;
                  
                                ResetFieldState();
                                BuildField(allPortals.slice(), triangle);
                  
                                SelectFieldInDropDown(triangle);

                                // Restore DOM state
                                $("#results").show();
                                $("#border").show();
                                const map_div = document.getElementById("map_canvas");
                                map_div.style.height = "50%";
                                $("#prompt").html("");
                            }
                            else {
                                // Select it
                                markers[portal.guid].setIcon({url: './images/hum_reso_08.png', scaledSize: new google.maps.Size(20, 20), anchor: new google.maps.Point(10,10)});
                                if (selectedPortals.length == 1) {
                                    polyLine = new google.maps.Polyline({
                                        path: [new google.maps.LatLng(portal),
                                               new google.maps.LatLng(selectedPortals[0])],
                                        strokeColor: '#FFFF00',
                                        strokeOpacity: 1.0,
                                        strokeWeight: 2,
                                        map: map
                                    });
                                    fieldSpecificMapElements.push(polyLine);
                                }
                                selectedPortals.push(portal);
                            }
                        }
                  
                        let infoWindow = jQuery.data(this, "infoWindow");
                        infoWindow.close();
                    }
                };

                let infoWindow = new google.maps.InfoWindow({
                    content: div
                });
                jQuery.data(div, "infoWindow", infoWindow);

                google.maps.event.addListener(marker, 'click', function () {
                    infoWindow.open(map, marker);
                });
                
                allPortals.push(data.portals[i]);
            }
            
            // Load the previously entered field parameters from Indexed DB
            let request = window.indexedDB.open("Fields", 1);
            request.onerror = function(event) {
                console.error("openDB:", event.target.errorCode);
                fieldDB = false;
            };
            request.onsuccess = function(event) {
                fieldDB = event.target.result;
                let store = fieldDB.transaction(['fields'],'readonly').objectStore('fields');
                store.getAll().onsuccess = function(e) {
                    if (e.target.result) {
                        let result = e.target.result;
                        result.forEach(function(field) {
                            $('#playbox').append($('<option>', {
                                value: field.guid,
                                text : field.title
                            }));
                        });
                    }
                  
                    let guid = GetURLParameter("guid");
                    if (typeof guid != "undefined") {
                        let triangle = ParseExtendedFieldGuid(guid);
                        SelectFieldInDropDown(triangle);
                        BuildField(allPortals.slice(), triangle);
                    }
                    else {
                        let bounds = GetURLParameter("pls");
                        if (typeof bounds != "undefined") {
                            bounds = PlsArgToArray(bounds);
                            let indices = [];
                            for (let seg=0; seg<bounds.length; seg++) {
                                let index = FindIndex(allPortals, bounds[seg].slice(0,2));
                                if (!indices.includes(index)) indices.push(index);
                                index = FindIndex(allPortals, bounds[seg].slice(2,4));
                                if (!indices.includes(index)) indices.push(index);
                            }
                  
                            // If it's a field we already know about, select it.  Otherwise add it & select it.
                            let triangle = [allPortals[indices[0]], allPortals[indices[1]], allPortals[indices[2]]];
                            SelectFieldInDropDown(triangle);
                  
                            BuildField(allPortals.slice(), triangle);
                        }
                    }
                }
            }
            request.onupgradeneeded = function(event) {
                fieldDB = event.target.result;
                keyStore = fieldDB.createObjectStore("fields", { keyPath: "guid" });
            }
            
            // Field selection
            $('#playbox').change(function () {
                var optionSelected = $(this).find("option:selected");
                var valueSelected  = optionSelected.val();
                if (valueSelected=="New") {
                    // Clickity clickity
                    ResetFieldState(); // clear the map
                    // maximize the map
                    $("#results").hide();
                    $("#border").hide();
                    const map_div = document.getElementById("map_canvas");
                    map_div.style.height = "100%";
                    $("#prompt").html("<p>Select portals by clicking on the portal and then on it's name.</p>");
                    selectingPortals = true;
                }
                else if (valueSelected=="Clear") {
                    if ($('#playbox option').length < 4) {
                        // We only have "Select", "New", "Clear"
                        $("#dialog").dialog({
                            modal:true,
                            title:'Nothing to clear.  Build some fields first.',
                            buttons: {
                                Ok: function() {
                                    $( this ).dialog( "close" );
                                }
                            }
                        });
                    }
                    else {
                        $("#dialog").dialog({
                            modal:true,
                            title:'Delete all fields?',
                            buttons: {
                                Ok: function() {
                                    // Clear the UI
                                    $('#playbox option:gt(2)').remove().end();
                                    
                                    // Clear the DB
                                    if (fieldDB) {
                                        let store = fieldDB.transaction(['fields'],'readwrite').objectStore('fields');
                                        store.clear();
                                    }
                                    
                                    // Clear any field that was drawn
                                    ResetFieldState();
                                    
                                    $( this ).dialog( "close" );
                                },
                                Cancel: function() {
                                    $( this ).dialog( "close" );
                                }

                            }
                        });
                    }
                }
                else if (valueSelected != "Select") {
                    // valueSelected is a FieldGuid
                    if (fieldDB) {
                        let objectStore = fieldDB.transaction(['fields'],'readonly').objectStore('fields');
                        let req = objectStore.openCursor(valueSelected);
                        req.onsuccess = function(e) {
                            let cursor = e.target.result;
                            const triangle = cursor.value.triangle;
                            ResetFieldState();
                            BuildField(allPortals.slice(), triangle);
                        }
                    }
                }
             });
            
            
            // Div resizing
            const map_div = document.getElementById("map_canvas");
            const border = document.getElementById("border");
            const panel = document.getElementById("results");
            
            let m_pos;
            function resize(e){
                const dy = m_pos - e.y;
                m_pos = e.y;
                panel.style.height = (parseInt(getComputedStyle(panel, '').height) + dy) + "px";
                map_div.style.height = (parseInt(getComputedStyle(map_div, '').height) - dy) + "px";
            }

            border.addEventListener("mousedown", function(e){
                m_pos = e.y;
                document.addEventListener("mousemove", resize, false);
            }, false);
            
            document.addEventListener("mouseup", function(){
                document.removeEventListener("mousemove", resize, false);
            }, false);
        })
        .fail(function(jqXHR, textStatus, errorThrown) {
            console.log('getJSON request failed! ' + textStatus); 
            console.log("incoming Text " + jqXHR.responseText);
        });
    } 
}

</script>
</head>

<body>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
<script>
    $.getJSON('apikey.json', function (data) {
        var s = document.createElement("script");
        s.type = "text/javascript";
        s.src = "http://maps.googleapis.com/maps/api/js?key=" + data.key + "&callback=initializeMap";
        $("head").append(s);
    })
    .fail(function(jqXHR, textStatus, errorThrown) { 
        console.log('getJSON request failed! ' + textStatus); 
        console.log("incoming Text " + jqXHR.responseText);
    });
</script>
<div class="container">
    <div id="menu">
        <select id="playbox">
            <option value="Select"><i>Select field...</i></option>
            <option value="New">&lt;New...&gt;</option>
            <option value="Clear">&lt;Clear...&gt;</option>
        </select>
        <div id="prompt"></div>
    </div>
    <div id="map_canvas"></div>
    <div id="border"></div>
    <div id="results">
        <p id="layer_count"></p>
        <p id="keys_heading"></p><ul id="keys_required" class="no_bullet"></ul>
        <p id="links_heading"></p><ul id="links" class="no_bullet"></ul>
        <p><a id="outer_triangle" href="" target="_blank"></a></p>
        <p><a id="share" href="" target="_blank"></a></p>
    </div>
</div>
<div id="dialog"></div>
</body>
</html>
