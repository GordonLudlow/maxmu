<!DOCTYPE html>
<!--
 MaxMu: Given a set of points (in lat,lng), find the largest area triangle.  From the set of points within that triangle (including 2 of the three outer triangle vertices), find the second largest triangle.  Repeat until there are no points within the innermost triangle.
 In the degenerate case, this will yield a standard layered field, but in the typical case the spine will be non-continuous.  Build the field inside out, creating the triangle first and then linking to the third portal of the inner triangle.
-->
<html>
<head>
<title>Max Mu</title>
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
<style type="text/css">
html { height: 100%; }
body { height: 100%; margin: 0; padding: 0; }
.container {display: flex; height: 100%; flex-direction: column;}
#map_canvas {width:100%; height:50%; min-height: 200px;}
#border {width: 100%; height: 1%; min-height: 5px; background-color: #0078B5; cursor: ns-resize;}
#results {width:100%; height:49%; overflow:auto; min-height: 100px;}
ul.no_bullet {list-style-type: none; padding: 0; margin: 0; }
li.checked {background: url('./images/checked.png') no-repeat left top; padding-left: 36px; padding-top: 4px; line-height: 1.5em; height:auto}
li.unchecked {background: url('./images/unchecked.png') no-repeat left top; padding-left: 36px; padding-top: 4px; line-height: 1.5em; height:auto}
</style>

<script type="text/javascript">

// https://github.com/indy256/convexhull-js/blob/master/convexhull.js
(function () {
 'use strict';
 
 function convexHull(points) {
 points.sort(function (a, b) {
             return a.x != b.x ? a.x - b.x : a.y - b.y;
             });
 
 var n = points.length;
 var hull = [];
 
 for (var i = 0; i < 2 * n; i++) {
 var j = i < n ? i : 2 * n - 1 - i;
 while (hull.length >= 2 && removeMiddle(hull[hull.length - 2], hull[hull.length - 1], points[j]))
 hull.pop();
 hull.push(points[j]);
 }
 
 hull.pop();
 return hull;
 }
 
 function removeMiddle(a, b, c) {
 var cross = (a.x - b.x) * (c.y - b.y) - (a.y - b.y) * (c.x - b.x);
 var dot = (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y);
 return cross < 0 || cross == 0 && dot <= 0;
 }
 
 // export as AMD module / Node module / browser or worker variable
 if (typeof define === 'function' && define.amd) define(function () { return convexHull; });
 else if (typeof module !== 'undefined') module.exports = convexHull;
 else if (typeof self !== 'undefined') self.convexHull = convexHull;
 else window.convexHull = convexHull;
 })();

// https://github.com/mattdesl/point-in-triangle (hacked a bit for the different data format)
function pointInTriangle(point, triangle) {
    //compute vectors & dot products
    var cx = point.x, cy = point.y,
        t0 = triangle[0], t1 = triangle[1], t2 = triangle[2],
        v0x = t2.x-t0.x, v0y = t2.y-t0.y,
        v1x = t1.x-t0.x, v1y = t1.y-t0.y,
        v2x = cx-t0.x, v2y = cy-t0.y,
        dot00 = v0x*v0x + v0y*v0y,
        dot01 = v0x*v1x + v0y*v1y,
        dot02 = v0x*v2x + v0y*v2y,
        dot11 = v1x*v1x + v1y*v1y,
        dot12 = v1x*v2x + v1y*v2y

    // Compute barycentric coordinates
    var b = (dot00 * dot11 - dot01 * dot01),
        inv = b === 0 ? 0 : (1 / b),
        u = (dot11*dot02 - dot01*dot12) * inv,
        v = (dot00*dot12 - dot01*dot02) * inv
    return u>=0 && v>=0 && (u+v < 1)
}

function GetURLParameter(sParam)
{
    let sPageURL = window.location.search.substring(1);
    let sURLVariables = sPageURL.split('&');
    for (let i = 0; i < sURLVariables.length; i++)
    {
        let sParameterName = sURLVariables[i].split('=');
        if (sParameterName[0] == sParam)
        {
            return sParameterName[1];
        }
    }
}

function PlsArgToArray(plsArg) {
    if (plsArg.includes("_")) {
        return plsArg.split("_").map(function(e) {
            return e.split(",").map(Number);
        });
    }
    return plsArg.split(",").map(Number);
}

var triangleCount = 0;
var maxLayers = 9999;
var keysRequired = {};

function IncrementKeyCount(portal, count) {
    // We're using this portal for the field, change its icon
    markers[portal.marker].setIcon({url: './images/hum_reso_08.png', scaledSize: new google.maps.Size(20, 20), anchor: new google.maps.Point(10,10)});
    if (keysRequired.hasOwnProperty(portal.guid)) {
        keysRequired[portal.guid].count += count;
    }
    else {
        keysRequired[portal.guid] = {guid: portal.guid, count: count, title: portal.title, lat: portal.lat, lng: portal.lng};
    }
}

function FindLargestInnerTriangle(triangle, portal) {
    // Cull points not strictly in the triangle
    for (let i=0; i<portal.length; ) {
        if (portal[i] == triangle[0]
        || portal[i] == triangle[1]
        || portal[i] == triangle[2]
        || !pointInTriangle(portal[i], triangle)) {
            portal.splice(i,1);
        }
        else {
            i++;
        }
    }
    
    if (!portal.length || triangleCount == maxLayers) {
        // We're at the end which is really the beginning.
        // The throws don't matter on this inner triangle.  One portal needs no keys, one needs a key and the third needs 2 keys.
        // So pick the one with the most keys already required to thow from so we don't increase it's count any more.
        triangle.sort((a,b) => {
            let aCount = 0;
            let bCount = 0;
            if (keysRequired.hasOwnProperty(a.guid)) {
                aCount = keysRequired[a.guid].count
            }
            if (keysRequired.hasOwnProperty(b.guid)) {
                bCount = keysRequired[b.guid].count
            }
            return bCount - aCount;
        });
        IncrementKeyCount(triangle[0], 0);
        IncrementKeyCount(triangle[1], 1);
        IncrementKeyCount(triangle[2], 2);
        
        let compositeGuid = triangle[0].guid + "_" + triangle[1].guid + "_" + triangle[2].guid;
        $("#links").append("<li class=\"unchecked\" id=\""
            + compositeGuid
            + "\">"
            + "Link <a href="
            + `"https://intel.ingress.com/intel?pll=${triangle[0].lat},${triangle[0].lng}" target="_blank">`
            + `${triangle[0].title}</a>`
            + " to <br /> <a href="
            + `"https://intel.ingress.com/intel?pll=${triangle[1].lat},${triangle[1].lng}" target="_blank">`
            + `${triangle[1].title}</a>`
            + " and <br /> <a href="
            + `"https://intel.ingress.com/intel?pll=${triangle[2].lat},${triangle[2].lng}" target="_blank">`
            + `${triangle[2].title}</a>`
            + "</li>");
        $("#"+compositeGuid).data("checked", false);
        
        compositeGuid = triangle[1].guid + "_" + triangle[2].guid;
        $("#links").append("<li class=\"unchecked\" id=\""
            + compositeGuid
            + "\">"
            + "Link <a href="
            + `"https://intel.ingress.com/intel?pll=${triangle[1].lat},${triangle[1].lng}" target="_blank">`
            + `${triangle[1].title}</a>`
            + " to <br /> <a href="
            + `"https://intel.ingress.com/intel?pll=${triangle[2].lat},${triangle[2].lng}" target="_blank">`
            + `${triangle[2].title}</a>`
            + "</li>");
        
        return;
    }
    
    triangleCount++;
    
    let maxArea = 0;
    let innerTriangle = [];
    let previousPoint = {};
    for (let i=0; i<portal.length; i++) {
        let a = portal[i];
        for (let exclude=0; exclude<3; exclude++) {
            let tempTri = JSON.parse(JSON.stringify(triangle));
            let excluded = JSON.parse(JSON.stringify(tempTri[exclude]));
            tempTri.splice(exclude,1);
            
            let b = tempTri[0];
            let c = tempTri[1];

            let area = Math.abs(
                (a.x * (b.y-c.y))
                + (b.x * (c.y-a.y))
                + (c.x * (a.y-b.y))
            );
            if (area > maxArea) {
                maxArea = area;
                innerTriangle = [a, b, c];
                previousPoint = excluded;
            }
        }
    }
    
    // Draw the inner triangle
    let polygon = new google.maps.Polygon({
        paths: innerTriangle,
        strokeColor: '#0000FF',
        strokeOpacity: 1,
        strokeWeight: 2,
        fillColor: '#0000FF',
        fillOpacity: 0.05,
        map: map
    });
    
    // Draw the spine segment
    polyLine = new google.maps.Polyline({
                path: [new google.maps.LatLng(innerTriangle[0]),
                       new google.maps.LatLng(previousPoint)],
                    strokeColor: '#FF0000',//lineColors[to],
                    strokeOpacity: 1.0,
                    strokeWeight: 2,
                    map: map
    });
    
    IncrementKeyCount(previousPoint, 0);
    IncrementKeyCount(innerTriangle[0], 1);
    IncrementKeyCount(innerTriangle[1], 1);
    IncrementKeyCount(innerTriangle[2], 1);
    
    //logString = "Link "         +   previousPoint.title + " https://intel.ingress.com/intel?pll=" +    previousPoint.lat + "," +    previousPoint.lng +
    //            " to "          + innerTriangle[1].title + " https://intel.ingress.com/intel?pll=" + innerTriangle[1].lat + "," + innerTriangle[1].lng +
    //            " and "         + innerTriangle[2].title + " https://intel.ingress.com/intel?pll=" + innerTriangle[2].lat + "," + innerTriangle[2].lng +
    //            " and then to " + innerTriangle[0].title + " https://intel.ingress.com/intel?pll=" + innerTriangle[0].lat + "," + innerTriangle[0].lng + "\n";

    FindLargestInnerTriangle(innerTriangle, portal);
    
    let compositeGuid = previousPoint.guid + "_" + innerTriangle[1].guid + "_" + innerTriangle[2].guid + "_" + innerTriangle[0].guid;
    $("#links").append("<li class=\"unchecked\" id=\""
        + compositeGuid
        + "\">"
        + "Link <a href="
        + `"https://intel.ingress.com/intel?pll=${previousPoint.lat},${previousPoint.lng}" target="_blank">`
        + `${previousPoint.title}</a>`
        + " to <br /> <a href="
        + `"https://intel.ingress.com/intel?pll=${innerTriangle[1].lat},${innerTriangle[1].lng}" target="_blank">`
        + `${innerTriangle[1].title}</a>`
        + " and <br /> <a href="
        + `"https://intel.ingress.com/intel?pll=${innerTriangle[2].lat},${innerTriangle[2].lng}" target="_blank">`
        + `${innerTriangle[2].title}</a>`
        + " and then to <br /> <a href="
        + `"https://intel.ingress.com/intel?pll=${innerTriangle[0].lat},${innerTriangle[0].lng}" target="_blank">`
        + `${innerTriangle[0].title}</a>`
        + "</li>");
    $("#"+compositeGuid).data("checked", false);
}

function FindIndex(portal, latlng) {
    for (let i=0; i<portal.length; i++) {
        if (portal[i].lat == latlng[0] && portal[i].lng == latlng[1]) {
            return i;
        }
    }
    console.log(`Error: Specified portal not found.  latlng = ${latlng[0]}, ${latlng[1]}`);
    $("#results").append(`<p><font color="red">ERROR</font>&nbsp;<a href="https://intel.ingress.com/intel?pll=${latlng[0]},${latlng[1]}" target="_blank">Unknown portal</a></p>`);

}

function SanitizeGuid(guid) {
    // Convert the guid into a string that can be used as an ID for a DOM element
    const reservedCharacters = "!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~";
    let sanitized = "";
    if (guid[0] >= '0' && guid[0] <= '9') {
        sanitized = "g";
    }
    for (let i=0; i<guid.length; i++) {
        if (reservedCharacters.includes(guid[i])) {
            sanitized += "_";
        }
        else {
            sanitized += guid[i];
        }
    }
    return sanitized;
}

var map;
var mapInitialized = false;

var db = false; // IndexedDB database of which checkboxes are checked
// One table in the DB.
// checkboxStore: guid => guid, checked

var markers = [];

function initializeMap()
{
    if (!mapInitialized)
    {
        // Default map options
        var mapOptions = { center: new google.maps.LatLng(47.488451,-122.169666),
                            zoom: 15,
                            mapTypeId: google.maps.MapTypeId.ROADMAP };
        
        map = new google.maps.Map(document.getElementById("map_canvas"), mapOptions);
        mapInitialized=true;

        // Load the portal coordinates
        // [{"title":"Title", "guid":"guid", "latlng":"lat,lng"},...]
        $.ajaxSetup({
            cache:false
        });          
        $.getJSON('portals.json', function (data) {
            let ignore = data.ignore;
            let portal = [];
            for (let i=0; i<data.portals.length; i++) {
                let latlngArray = data.portals[i].latlng.split(',');
                let lat = parseFloat(latlngArray[0]);
                let lng = parseFloat(latlngArray[1]);
                
                if (ignore.some(e => e.guid === data.portals[i].guid)) {
                    console.log("Skipping " + data.portals[i].title);
                    let marker = new google.maps.Marker({
                        position: new google.maps.LatLng(lat, lng),
                        map: map,
                        icon: {url: './images/neutral.png', scaledSize: new google.maps.Size(20, 20), anchor: new google.maps.Point(10,10)},
                        title: data.portals[i].title + " " + data.portals[i].latlng
                    });
                    let infoWindow = new google.maps.InfoWindow({
                        content: data.portals[i].title + " " + data.portals[i].latlng
                    });
                    google.maps.event.addListener(marker, 'click', function () {
                        infoWindow.open(map, marker);
                    });
                    continue;
                }

                data.portals[i].lat = lat;
                data.portals[i].lng = lng;
                data.portals[i].x = lng; // convexHull function wants x,y
                data.portals[i].y = lat;
                data.portals[i].guid = SanitizeGuid(data.portals[i].guid);
                
                let marker = new google.maps.Marker({
                  position: new google.maps.LatLng(lat, lng),
                  map: map,
                  icon: {url: './images/enl_reso_01.png', scaledSize: new google.maps.Size(20, 20), anchor: new google.maps.Point(10,10)},
                  title: data.portals[i].title + " " + data.portals[i].latlng
                });
                let infoWindow = new google.maps.InfoWindow({
                    content: data.portals[i].title + " " + data.portals[i].latlng
                });
                google.maps.event.addListener(marker, 'click', function () {
                    infoWindow.open(map, marker);
                });
                
                data.portals[i].marker = markers.push(marker) - 1;
                
                portal.push(data.portals[i]);
            }
  
            // TODO: Move all the math to a web worker.  Also, move the javascript and css out of index.html.
            let triangle = [];
            
            let bounds = GetURLParameter("pls");
            if (typeof bounds != "undefined") {
                bounds = PlsArgToArray(bounds);
                let indices = [];
                for (let seg=0; seg<bounds.length; seg++) {
                    let index = FindIndex(portal, bounds[seg].slice(0,2));
                    if (!indices.includes(index)) indices.push(index);
                    index = FindIndex(portal, bounds[seg].slice(2,4));
                    if (!indices.includes(index)) indices.push(index);
                }
                triangle = [portal[indices[0]], portal[indices[1]], portal[indices[2]]];
            }
            else {
                // Make them pick a triangle
                window.location.replace("./select_triangle.html");
                /*
                // Find largest triangle
                let maxArea = 0;
                let hull = convexHull(portal);
                for (let a=0; a<hull.length-2; a++) {
                    for (let b=a+1; b<hull.length-1; b++) {
                        for (let c=b+1; c<hull.length; c++) {
                            // Find twice the area of the triangle abc
                            let area = Math.abs(
                                (hull[a].x * (hull[b].y-hull[c].y))
                                + (hull[b].x * (hull[c].y-hull[a].y))
                                + (hull[c].x * (hull[a].y-hull[b].y))
                                );
                            if (area > maxArea) {
                                maxArea = area;
                                triangle = [hull[a], hull[b], hull[c]];
                            }
                        }
                    }
                }
                */
            }
            
            // Draw the triangle
            let polygon = new google.maps.Polygon({
                paths: triangle,
                strokeColor: '#0000FF',
                strokeOpacity: 1,
                strokeWeight: 2,
                fillColor: '#0000FF',
                fillOpacity: 0.1,
                map: map
            });
                  
            triangleCount++;
            FindLargestInnerTriangle(triangle, portal); // Recursively find all the triangles
            $("#links_heading").html("Links:");
            
            $("#layer_count").html(triangleCount + " layers");
            
            let sortedKeys = [];
            for (let key in keysRequired) {
                if (keysRequired.hasOwnProperty(key)) {
                    sortedKeys.push(keysRequired[key]);
                }
            }
            sortedKeys.sort((a, b) => b.count - a.count);
            for (let key in sortedKeys) {
                $("#keys_required").append("<li class=\"unchecked\" id=\""
                    + sortedKeys[key].guid
                    + "\">"
                    + ("    " + sortedKeys[key].count).slice(-4)
                    + " <a href="
                    + `"https://intel.ingress.com/intel?pll=${sortedKeys[key].lat},${sortedKeys[key].lng}" target="_blank">`
                    + `${sortedKeys[key].title}</a>`
                    + "</li>");
                $("#"+sortedKeys[key].guid).data("checked", false);
            }
            $("#keys_heading").html(function(items, prop){
                return items.reduce( function(a, b){
                    return a + b[prop];
                }, 0)}(sortedKeys, "count") + " keys required:");
                  
            let center = {};
            center.lat = (triangle[0].lat + triangle[1].lat + triangle[2].lat)/3;
            center.lng = (triangle[0].lng + triangle[1].lng + triangle[2].lng)/3;
            map.setCenter(new google.maps.LatLng(center));
            
            // The stock intel page errors out with more than a dozen triangles.  So let's just do the outermost
            $("#outer_triangle").attr('href',
                "https://intel.ingress.com/intel?ll="
                + center.lat
                + ","
                + center.lng
                + "&pls="
                + triangle[0].lat + "," + triangle[0].lng + "," + triangle[1].lat + "," + triangle[1].lng
                + "_" + triangle[0].lat + "," + triangle[0].lng + "," + triangle[2].lat + "," + triangle[2].lng
                + "_" + triangle[1].lat + "," + triangle[1].lng + "," + triangle[2].lat + "," + triangle[2].lng);
            $("#outer_triangle").html("Outer triangle");

            // Open the IndexedDB containing which checkboxes should be checked
            let guids = [triangle[0].guid, triangle[1].guid, triangle[2].guid];
            guids.sort();
            let request = window.indexedDB.open("MaxMu" + guids[0] + "_" + guids[1] + "_" + guids[2], 1);
            request.onerror = function(event) {
                console.error("openDb:", event.target.errorCode);
                db = false;
            };
            request.onsuccess = function(event) {
                db = event.target.result;
                let store = db.transaction(['checkboxes'],'readonly').objectStore('checkboxes');
                store.getAll().onsuccess = function(e) {
                    if (e.target.result) {
                        let result = e.target.result;
                        result.forEach(function(checkBoxRecord) {
                            // change the checkedness of the element using it's id/guid to look it up.
                            if (checkBoxRecord.checked) { // we default to unchecked, so only have to change it if it's checked
                                let checkBox = $("#"+checkBoxRecord.guid);
                                checkBox.data("checked", true);

                                checkBox.addClass("checked");
                                checkBox.removeClass("unchecked");
                            }
                        });
                    }
                };
            };
            request.onupgradeneeded = function(event) {
                db = event.target.result;
                keyStore = db.createObjectStore("checkboxes", { keyPath: "guid" });
            }

            // Check box toggling
            $("li").on("click", function(event) {
                if (event.target === event.currentTarget) { // only consume clicks on the bullet.  The content of the li is a link.
                    $(this).toggleClass("unchecked");
                    $(this).toggleClass("checked");
                    if (db) {
                        let objectStore = db.transaction(['checkboxes'],'readwrite').objectStore('checkboxes');
                        let guid = $(this).attr('id');
                        let checked = $(this).hasClass("checked");
                        let req = objectStore.openCursor(guid);
                        req.onsuccess = function(e) {
                            let cursor = e.target.result;
                            if (cursor) { // key already exists
                                const updateData = cursor.value;
                                updateData.checked = checked;
                                cursor.update(updateData);
                            } else { // key does not exist
                                objectStore.add({guid: guid, checked: checked});
                            }
                        };
                    }
                    return false;
                }
                return true;
            });
            
            // Div resizing
            const map_div = document.getElementById("map_canvas");
            const border = document.getElementById("border");
            const panel = document.getElementById("results");
            
            let m_pos;
            function resize(e){
                const dy = m_pos - e.y;
                m_pos = e.y;
                panel.style.height = (parseInt(getComputedStyle(panel, '').height) + dy) + "px";
                map_div.style.height = (parseInt(getComputedStyle(map_div, '').height) - dy) + "px";
            }

            border.addEventListener("mousedown", function(e){
                m_pos = e.y;
                document.addEventListener("mousemove", resize, false);
            }, false);
            
            document.addEventListener("mouseup", function(){
                document.removeEventListener("mousemove", resize, false);
            }, false);
        })
        .fail(function(jqXHR, textStatus, errorThrown) { 
            console.log('getJSON request failed! ' + textStatus); 
            console.log("incoming Text " + jqXHR.responseText);
        });
    } 
}

</script>
</head>

<body>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script>
    $.getJSON('apikey.json', function (data) {
        var s = document.createElement("script");
        s.type = "text/javascript";
        s.src = "http://maps.googleapis.com/maps/api/js?key=" + data.key + "&callback=initializeMap";
        $("head").append(s);
    })
    .fail(function(jqXHR, textStatus, errorThrown) { 
        console.log('getJSON request failed! ' + textStatus); 
        console.log("incoming Text " + jqXHR.responseText);
    });
</script>
<div class="container">
    <div id="map_canvas"></div>
    <div id="border"></div>
    <div id="results">
        <p id="layer_count"></p>
        <p id="keys_heading"></p><ul id="keys_required" class="no_bullet"></ul>
        <p id="links_heading"></p><ul id="links" class="no_bullet"></ul>
        <p><a id="outer_triangle" href=""></a></p>
    </div>
</div>
</body>
</html>
